<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paul Edmunds - Demo</title>
    <style>
        body, html { margin: 0; height: 100%; overflow: hidden; font-family: Arial, sans-serif; }
        #overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; text-align: center; }
        h1 { margin: 0 0 10px; font-size: 3em; }
        a { color: #88f; text-decoration: none; font-size: 1.2em; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>Paul Edmunds</h1>
        <p>Check out <a href="https://www.linkedin.com/in/paul-s-edmunds/" target="_blank" rel="noopener">his LinkedIn profile</a>.</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script>
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0xcce0ff, 0.02);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 200);
        camera.position.set(0, 10, 24);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ground = new THREE.Mesh(
            new THREE.PlaneGeometry(60, 60),
            new THREE.MeshStandardMaterial({ color: 0x556b2f })
        );
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const board = new THREE.Mesh(
            new THREE.BoxGeometry(16, 0.5, 4),
            new THREE.MeshStandardMaterial({ color: 0xdeb887 })
        );
        board.position.y = -0.25;
        scene.add(board);

        const loader = new THREE.GLTFLoader();
        const fernUrl = 'https://rawcdn.githack.com/mrdoob/three.js/r146/examples/models/gltf/Fern.glb';
        for (let i = 0; i < 3; i++) {
            loader.load(fernUrl, gltf => {
                const fern = gltf.scene;
                fern.scale.set(5, 5, 5);
                fern.position.set(-10 + i * 10, 0, -5);
                scene.add(fern);
            });
        }

        const pegGeometry = new THREE.CylinderGeometry(0.2, 0.2, 6);
        const pegMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
        const pegPositions = [-6, 0, 6];
        const pegs = [[], [], []];
        pegPositions.forEach(x => {
            const peg = new THREE.Mesh(pegGeometry, pegMaterial);
            peg.position.set(x, 3, 0);
            scene.add(peg);
        });

        const discHeight = 0.5;
        const colors = [0x8B5A2B,0xA0522D,0xCD853F,0xD2B48C,0xDEB887,0xBC8F8F,0xF4A460,0xCDAA7D];
        const discs = [];
        for (let i = 0; i < 8; i++) {
            const radius = 3 - i * 0.3;
            const geometry = new THREE.CylinderGeometry(radius, radius, discHeight, 32);
            const material = new THREE.MeshStandardMaterial({ color: colors[i % colors.length] });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(pegPositions[0], discHeight / 2 + i * discHeight, 0);
            scene.add(mesh);
            discs.push(mesh);
            pegs[0].push(mesh);
        }

        const moves = [];
        function hanoi(n, from, to, via) {
            if (n > 0) {
                hanoi(n - 1, from, via, to);
                moves.push([from, to]);
                hanoi(n - 1, via, to, from);
            }
        }

        hanoi(discs.length, 0, 2, 1);
        let moveIndex = 0;

        function doMove() {
            if (moveIndex >= moves.length) {
                setTimeout(resetGame, 1000);
                return;
            }
            const [from, to] = moves[moveIndex++];
            const disc = pegs[from].pop();
            const lift = 5;
            const targetX = pegPositions[to];
            const targetY = discHeight / 2 + pegs[to].length * discHeight;

            const up = new TWEEN.Tween(disc.position).to({ y: lift }, 300).easing(TWEEN.Easing.Quadratic.Out);
            const across = new TWEEN.Tween(disc.position).to({ x: targetX }, 600).easing(TWEEN.Easing.Quadratic.InOut);
            const down = new TWEEN.Tween(disc.position).to({ y: targetY }, 300).easing(TWEEN.Easing.Quadratic.In)
                .onComplete(() => {
                    pegs[to].push(disc);
                    doMove();
                });
            up.chain(across);
            across.chain(down);
            up.start();
        }

        doMove();

        const rainGeo = new THREE.BufferGeometry();
        const rainCount = 1000;
        const rainPos = [];
        for (let i = 0; i < rainCount; i++) {
            rainPos.push((Math.random() - 0.5) * 60, Math.random() * 20 + 10, (Math.random() - 0.5) * 60);
        }
        rainGeo.setAttribute('position', new THREE.Float32BufferAttribute(rainPos, 3));
        const rainMat = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.1 });
        const rain = new THREE.Points(rainGeo, rainMat);
        scene.add(rain);

        function resetGame() {
            moveIndex = 0;
            moves.length = 0;
            pegs[0] = [];
            pegs[1] = [];
            pegs[2] = [];
            discs.forEach((disc, i) => {
                disc.position.set(pegPositions[0], discHeight / 2 + i * discHeight, 0);
                pegs[0].push(disc);
            });
            hanoi(discs.length, 0, 2, 1);
            doMove();
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            const pos = rain.geometry.attributes.position.array;
            for (let i = 0; i < pos.length; i += 3) {
                pos[i + 1] -= 0.2;
                if (pos[i + 1] < 0) pos[i + 1] = Math.random() * 20 + 10;
            }
            rain.geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
