<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paul Edmunds - Demo</title>
    <style>
        body, html { margin: 0; height: 100%; overflow: hidden; font-family: Arial, sans-serif; }
        #overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; text-align: center; }
        h1 { margin: 0 0 10px; font-size: 3em; }
        a { color: #88f; text-decoration: none; font-size: 1.2em; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>Paul Edmunds</h1>
        <p>Check out <a href="https://www.linkedin.com/in/paul-s-edmunds/" target="_blank" rel="noopener">his LinkedIn profile</a>.</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 8, 18);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const board = new THREE.Mesh(
            new THREE.BoxGeometry(16, 0.5, 4),
            new THREE.MeshStandardMaterial({ color: 0x8b7765 })
        );
        board.position.y = -0.25;
        scene.add(board);

        const pegGeometry = new THREE.CylinderGeometry(0.2, 0.2, 6);
        const pegMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
        const pegPositions = [-6, 0, 6];
        const pegs = [[], [], []];
        pegPositions.forEach(x => {
            const peg = new THREE.Mesh(pegGeometry, pegMaterial);
            peg.position.set(x, 3, 0);
            scene.add(peg);
        });

        const discHeight = 0.5;
        const colors = ['#228B22','#2E8B57','#6B8E23','#8FBC8F','#66CDAA','#BDB76B','#DAA520','#FFB6C1'];
        const discs = [];
        for (let i = 0; i < 8; i++) {
            const radius = 3 - i * 0.3;
            const geometry = new THREE.CylinderGeometry(radius, radius, discHeight, 32);
            const material = new THREE.MeshStandardMaterial({ color: colors[i % colors.length] });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(pegPositions[0], discHeight / 2 + i * discHeight, 0);
            scene.add(mesh);
            discs.push(mesh);
            pegs[0].push(mesh);
        }

        const moves = [];
        function hanoi(n, from, to, via) {
            if (n > 0) {
                hanoi(n - 1, from, via, to);
                moves.push([from, to]);
                hanoi(n - 1, via, to, from);
            }
        }

        hanoi(discs.length, 0, 2, 1);
        let moveIndex = 0;

        function doMove() {
            if (moveIndex >= moves.length) {
                setTimeout(resetGame, 1000);
                return;
            }
            const [from, to] = moves[moveIndex++];
            const disc = pegs[from].pop();
            const lift = 5;
            const targetX = pegPositions[to];
            const targetY = discHeight / 2 + pegs[to].length * discHeight;

            const up = new TWEEN.Tween(disc.position).to({ y: lift }, 300).easing(TWEEN.Easing.Quadratic.Out);
            const across = new TWEEN.Tween(disc.position).to({ x: targetX }, 600).easing(TWEEN.Easing.Quadratic.InOut);
            const down = new TWEEN.Tween(disc.position).to({ y: targetY }, 300).easing(TWEEN.Easing.Quadratic.In)
                .onComplete(() => {
                    pegs[to].push(disc);
                    doMove();
                });
            up.chain(across);
            across.chain(down);
            up.start();
        }

        doMove();

        function resetGame() {
            moveIndex = 0;
            moves.length = 0;
            pegs[0] = [];
            pegs[1] = [];
            pegs[2] = [];
            discs.forEach((disc, i) => {
                disc.position.set(pegPositions[0], discHeight / 2 + i * discHeight, 0);
                pegs[0].push(disc);
            });
            hanoi(discs.length, 0, 2, 1);
            doMove();
        }

        function animate(time) {
            requestAnimationFrame(animate);
            TWEEN.update(time);
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
